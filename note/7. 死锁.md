## 死锁

#### 产生与判断

##### 必要条件

互斥（一个资源只能由一个进程占用）；占用并等待；非抢占（资源不能被抢占）；循环等待；

##### 资源分配图

有环可能死锁；无环无死锁；

#### 预防与避免

##### 预防死锁：确保至少一个必要条件不成立

###### 互斥（通常不能否定互斥）

###### 占有并等待

1，一次申请并获得所有资源；2，进程不占用资源的时候才能申请资源

上述两种方法缺点：资源利用率低，可能发生饥饿；

###### 非抢占

使用如下协议施行抢占：如果⼀个进程占有资源并申请另⼀个不能分配的资源，那么其现已分配的资源可被抢占；

实操：

> 资源可用:分配
>
> 不可用:
>
> >已分配给其他在等待额外资源的进程：抢占
> >
> >没有被其他等待额外资源的进程占有：等待
> >
> ><img src="md_image\image-20220523150744877.png" alt="image-20220523150744877" style="zoom:67%;" />



###### 循环等待（有序资源使用法可以打破）

为每个资源类型分配⼀个唯⼀的整数 

每个进程按递增顺序申请资源



##### 避免死锁：利用事先得到进程申请资源和使用资源的额外信息，判断每当发生资源请求时是否会发生死锁

避免死锁指的是确保系统不进入不安全状态

###### 单个实例：资源分配图（改进版）

需求边：虚线，表示将来可能会申请，需求边变成申请边（虚线变实线）需要验证是否成环；

申请边、分配边：实线



###### 多个实例：银行家算法

流程：每次请求资源的时候，先用资源请求算法，并且在资源请求算法中调用安全性检查，若通过安全性检查则允许此次请求。

数据结构：

available(vector) 表示可分配的资源数量

max(n$\times$m matrix) 表示资源最大需求数（其实没啥用）

allocation (n$\times$m matrix) 表示已经占有的资源数



**1.安全性检查**

<img src="md_image\image-20220612204941729.png" alt="image-20220612204941729" style="zoom:67%;" />

**2.资源请求算法**



<img src="md_image\image-20220612204955005.png" alt="image-20220612204955005" style="zoom:67%;" />







#### 死锁检测

死锁检测/恢复：类似safety check，但是略有不同

<img src="md_image\image-20220612213054178.png" alt="image-20220612213054178" style="zoom:67%;" />

证明：有序资源使用法情况下，不会产生循环等待；

#### 死锁恢复

##### 进程终止

1. 终⽌所有死锁进程 

2. ⼀次只终止⼀个进程直到取消死锁循环为止

##### 资源抢占

从进程中抢占资源给其他进程使用（<font color=red>需要防止饥饿</font>）

#### 反证法

##### 假设：

假设产生了循环等待，并且设⼀组等待进程 $ \{ P_0, P_1 , …, P_n \}$，他们对应等待的资源分别为$ \{ q_0, q_1 , …, q_n \}$；其中，$P_0$ 等待的资源$q_0$被 $P_1$ 所占 ，$P_1$ 等待的资源$q_1$被 $P_2$ 所占，…, $P_{n–1}$ 等待的资源$q_{n-1}$被 $P_n$所占， $P_n$等待的资源$q_n$被$P_0 $所占。

##### 证明：

在这些等待进程中，每个进程都必须按资源序号递增顺序申请资源。即有:

对于进程$P_0$分析, $q_0>a_0\ge q_n$，a为$P_0$进程所占有资源的最大序号； 			①



对于进程$P_n$分析，$P_n$占有$q_{n-1}$，等待$q_n$；即为：$q_n$>$q_{n-1}$    ② 

依此类推得到：$q_{n-1}>q_{n-2} ,q_{n-2}>q_{n-3},...,q_1>q_0$           ③

结合 ② ③式可得:$q_n>q_0$,但是这显然与①相矛盾，因此在有序资源使用法中，假设不成立。

综上，有序资源使用法情况下，不会产生循环等待；

预防和避免死锁

死锁的状态有几个=环有几个



